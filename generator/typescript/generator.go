package typescript

import (
	"fmt"
	"strings"

	"go.trulyao.dev/mirror/config"
	"go.trulyao.dev/mirror/generator"
	"go.trulyao.dev/mirror/parser"
	"go.trulyao.dev/mirror/types"
)

var fileHeader = `/**
* This file was generated by mirror, do not edit it manually as it will be overwritten.
*
* You can find the docs and source code for mirror here: https://github.com/aosasona/mirror
*/
`

type Generator struct {
	config *Config
	indent string
	parser types.ParserInterface
}

func NewGenerator(c *Config) *Generator {
	g := Generator{config: c}

	for i := 0; i < c.IndentationCount; i++ {
		if c.IndentationType == config.Space {
			g.indent += " "
		} else {
			g.indent += "\t"
		}
	}
	return &g
}

// SetParser implements generator.GeneratorInterface.
func (g *Generator) SetParser(parser types.ParserInterface) error {
	if parser == nil {
		return generator.ErrNoParser
	}

	g.parser = parser
	return nil
}

// GenerateItem implements types.GeneratorInterface.
func (g *Generator) GenerateItem(item parser.Item) (string, error) {
	var (
		typeString = "type %s = %s"
		baseType   string
		err        error
	)

	switch item := item.(type) {
	case parser.Scalar:
		baseType, err = g.generateScalar(item)
	case parser.List:
		baseType, err = g.generateList(item)
	case parser.Map:
	// TODO: implement
	case parser.Struct:
	// TODO: implement
	case parser.Function:
		baseType, err = g.generateFunction(item)
	default:
		return "", generator.ErrUnknownType
	}

	if err != nil {
		return "", err
	}

	if baseType == "" {
		return "", generator.ErrUnknownType
	}

	if item.IsNullable() {
		if g.config.PreferNullForNullable {
			baseType += " | null"
		} else {
			baseType += " | undefined"
		}
	}

	if g.config.InludeSemiColon {
		typeString = strings.TrimSpace(typeString) + ";"
	}

	return fmt.Sprintf(typeString, item.Name(), baseType), nil
}

// GenerateAll implements generator.GeneratorInterface.
func (g *Generator) GenerateAll() ([]string, error) {
	panic("unimplemented")
}

// GenerateN implements generator.GeneratorInterface.
func (g *Generator) GenerateN(int) (string, error) {
	panic("unimplemented")
}

// SetHeaderText implements generator.GeneratorInterface.
func (g *Generator) SetHeaderText(header string) {
	if header == "" {
		return
	}

	fileHeader = header
}

func (g *Generator) getTypescriptRepresentation(mirrorType parser.Type) string {
	var typeValue string

	switch mirrorType {
	case parser.TypeAny:
		typeValue = "any"
		if g.config.PreferUnknown {
			typeValue = "unknown"
		}
	case parser.TypeInteger, parser.TypeFloat:
		typeValue = "number"
	case parser.TypeString:
		typeValue = "string"
	case parser.TypeBoolean:
		typeValue = "boolean"
	case parser.TypeByte:
		typeValue = "string"
	// typeValue = "Uint8Array" // TODO: it should most definitely be Uint8Array but I'm not sure if it's a good idea currently with serialization and whatnot
	case parser.TypeTimestamp:
		typeValue = "string"
		// typeValue = "Date" // TODO: generate code to automatically handle this on the TS side if need be in the future like TypeByte
	default:
		return ""
	}

	return typeValue
}

func (g *Generator) generateScalar(item parser.Scalar) (string, error) {
	if item.Name() == "" {
		return "", generator.ErrNoName
	}

	typeValue := g.getTypescriptRepresentation(item.Type())
	if typeValue == "" {
		return "", generator.ErrUnknownType
	}

	return typeValue, nil
}

func (g *Generator) generateStruct(item parser.Struct) (string, error) {
	panic("unimplemented")
}

func (g *Generator) generateField(item parser.Field) (string, error) {
	// var (
	// 	fieldString = "%s%s: %s"
	// 	fieldName   = item.Name
	// 	fieldType   string
	// )

	// if item.BaseItem.IsScalar() {
	// 	fieldType = g.getTypescriptRepresentation(item.BaseItem.Type())
	// } else {
	// }

	panic("unimplemented")
}

func (g *Generator) generateList(item parser.List) (string, error) {
	var (
		listString = ""
		err        error
	)

	if g.config.PreferArrayGeneric {
		listString = "Array<%s>"
	} else {
		listString = "%s[]"
	}

	if item.Name() == "" {
		return "", generator.ErrNoName
	}

	if item.BaseItem == nil {
		return "", generator.ErrNoBaseItem
	}

	var baseType string
	if item.BaseItem.IsScalar() {
		if baseType, err = g.generateScalar(item.BaseItem.(parser.Scalar)); err != nil {
			return "", err
		}

		if item.BaseItem.IsNullable() {
			if g.config.PreferNullForNullable {
				baseType = fmt.Sprintf("%s | null", baseType)
			} else {
				baseType = fmt.Sprintf("%s | undefined", baseType)
			}

			if !g.config.PreferArrayGeneric {
				baseType = fmt.Sprintf("(%s)", baseType)
			}
		}
	} else {
		baseType = item.BaseItem.Name()
		if g.config.InlineObjects {
			if baseType, err = g.GenerateItem(item.BaseItem); err != nil {
				return "", err
			}
		}
	}

	return fmt.Sprintf(listString, baseType), nil
}

func (g *Generator) generateMap(item parser.List) (string, error) {
	panic("unimplemented")
}

func (g *Generator) generateFunction(item parser.Function) (string, error) {
	panic("unimplemented")
}

var _ types.GeneratorInterface = &Generator{}
