package mirror

import (
	"errors"
	"fmt"
	"os"
	"strings"

	"go.trulyao.dev/mirror/config"
	"go.trulyao.dev/mirror/generator"
	"go.trulyao.dev/mirror/helper"
)

type Sources []any

type Mirror struct {
	config  config.Config
	sources Sources
}

var (
	// for convenience
	String = helper.String
	Bool   = helper.Bool

	ErrNoSources    = errors.New("no sources provided")
	ErrNoOutputFile = errors.New("no output file provided")
)

const FileHeader = `/*
 * This file was generated by mirror, do not edit it manually
 * You can find the docs and source code at https://github.com/aosasona/mirror
 */
	`

// for convenience
type Config = config.Config

func DefaultConfig() Config {
	return config.Config{
		Enabled:               Bool(true),
		OutputFile:            String("types.ts"),
		UseTypeForObjects:     Bool(true),
		AllowUnexportedFields: Bool(false),
	}
}

func New(c config.Config) *Mirror {
	if c.OutputFile == nil || *c.OutputFile == "" {
		c.OutputFile = helper.String("types.ts")
	}

	return &Mirror{config: c}
}

// Fork takes the current mirror instance and returns a new instance with the current config.
// If replace it true, it replaces the current config with the new config entirely, else it only replaces the non-nil values.
func (g *Mirror) Fork(c config.Config, replaceConfig bool) *Mirror {
	fork := &Mirror{}

	if replaceConfig {
		fork.config = c
	} else {
		fork.config = g.config.Merge(c)
	}

	fork.sources = Sources{}

	return fork
}

func (m *Mirror) Count() int {
	return len(m.sources)
}

func (m *Mirror) AddSource(s any) {
	m.sources = append(m.sources, s)
}

func (m *Mirror) Commit(output string) error {
	if !m.config.EnabledOrDefault() {
		return nil
	}

	if m.config.OutputFileOrDefault() == "" {
		return ErrNoOutputFile
	}

	if m.areSameBytesContent(output) {
		fmt.Println("No changes detected, skipping...")
		return nil
	}

	err := os.WriteFile(m.config.OutputFileOrDefault(), []byte(output), 0644)
	if err != nil {
		return err
	}

	m.sources = Sources{}
	return nil
}

func (m *Mirror) Generate() (string, error) {
	if !m.config.EnabledOrDefault() {
		return "", nil
	}

	var output string

	if len(m.sources) == 0 {
		return "", ErrNoSources
	}

	gn := generator.NewGenerator(generator.Opts{
		UseTypeForObjects:     m.config.UseTypeForObjectsOrDefault(),
		ExpandStructs:         m.config.ExpandObjectTypesOrDefault(),
		PreferUnknown:         m.config.PreferUnknownOrDefault(),
		AllowUnexportedFields: m.config.AllowUnexportedFieldsOrDefault(),
	})

	for _, src := range m.sources {
		result := gn.Generate(src)
		output += result + ";\n\n"
	}

	output = FileHeader + "\n" + strings.TrimSpace(output)

	return output, nil
}

// This is mainly for testing purposes but you can use it to generate a single type
func (m *Mirror) GenerateSingle(src any) (string, error) {
	if !m.config.EnabledOrDefault() {
		return "", nil
	}

	gn := generator.NewGenerator(generator.Opts{
		UseTypeForObjects:     m.config.UseTypeForObjectsOrDefault(),
		ExpandStructs:         m.config.ExpandObjectTypesOrDefault(),
		PreferUnknown:         m.config.PreferUnknownOrDefault(),
		AllowUnexportedFields: m.config.AllowUnexportedFieldsOrDefault(),
	})

	return gn.Generate(src) + ";", nil
}

func (m *Mirror) Execute(log ...bool) error {
	output, err := m.Generate()
	if err != nil {
		return err
	}

	if len(log) > 0 && log[0] {
		fmt.Println(output)
	}

	return m.Commit(output)
}

// Calling Register will register the sources passed to it (doesn't replace the existing sources)
func (m *Mirror) Register(sources ...any) error {
	if !m.config.EnabledOrDefault() {
		return nil
	}

	if len(sources) == 0 {
		return ErrNoSources
	}

	m.sources = append(m.sources, sources...)

	return nil
}
